#!/usr/bin/env python3

import argparse
import pickle
from math import cos, radians, sin
from os import environ, makedirs, path

import eccodes
import numpy as np
import pandas as pd
from scipy.spatial import KDTree

pts_cache_dir = "PTS_CACHE_DIR"
pts_home_dir = "PTS_HOME_DIR"

parser = argparse.ArgumentParser()
parser.add_argument("--distance", help="Point search radius", default=2.0e5)
parser.add_argument("--ens-size", help="Ensemble size", default=50, type=int)
parser.add_argument("--grib-template", help="GRIB template", default="O640.grib1")
parser.add_argument("--grib-accuracy", help="GRIB bitsPerValue", default=8, type=int)
parser.add_argument("--grib-date", help="GRIB dataDate", default=None)
parser.add_argument("--grib-step", help="GRIB stepRange", default=None)

parser.add_argument(
    "--no-normalise",
    help="Values not normalised to [0, 1]",
    action="store_const",
    const=True,
    default=False,
)

parser.add_argument(
    "--caching",
    help="Caching (env. variable '" + pts_cache_dir + "')",
    action="store_true",
)

parser.add_argument("fin", help="Input points file", metavar="in")
parser.add_argument("fout", help="Output GRIB file", metavar="out")

args = parser.parse_args()
print(args)


def ll_to_ecef(lat, lon, height=0.0, radius=6371229.0):
    lonr = radians(lon)
    latr = radians(lat)

    x = (radius + height) * cos(latr) * cos(lonr)
    y = (radius + height) * cos(latr) * sin(lonr)
    z = (radius + height) * sin(latr)
    return x, y, z


if pts_home_dir in environ:
    tpl_dir = environ[pts_home_dir]
else:
    tpl_dir = path.dirname(__file__)
tpl_path = path.realpath(path.join(tpl_dir, args.grib_template))
print("Loading template: '{}'".format(tpl_path))

with open(tpl_path, "rb") as f:
    h = eccodes.codes_grib_new_from_file(f)
    assert h is not None

    N = eccodes.codes_get(h, "numberOfDataPoints")

    # k-d tree
    tree_path = eccodes.codes_get(h, "md5GridSection") + ".tree"
    if pts_cache_dir in environ:
        tree_path = path.join(environ[pts_cache_dir], tree_path)

    if args.caching and path.exists(tree_path):
        print("Loading cache file: '{}'".format(tree_path))
        with open(tree_path, "rb") as f:
            tree = pickle.load(f)
    else:
        it = eccodes.codes_grib_iterator_new(h, 0)

        P = np.empty([N, 3])
        i = 0
        while True:
            result = eccodes.codes_grib_iterator_next(it)
            if not result:
                break
            [lat, lon, value] = result

            assert i < N
            P[i, :] = ll_to_ecef(lat, lon)

            i += 1

        eccodes.codes_grib_iterator_delete(it)
        tree = KDTree(P)

    if args.caching and not path.exists(tree_path):
        print("Creating cache file: '{}'".format(tree_path))
        tpl_dir = path.dirname(tree_path)
        if tpl_dir:
            makedirs(tpl_dir, mode=888, exist_ok=True)
            assert path.isdir(tpl_dir)
        with open(tree_path, "wb") as f:
            pickle.dump(tree, f)

    # input
    df = pd.read_csv(
        args.fin,
        sep=r"\s+",
        header=None,
        names=["lat", "lon", "number", "date", "step", "?", "msl"],
        usecols=["lat", "lon", "number"],
    )

    # probability field
    val = np.zeros(N)
    for row in df.itertuples():
        if row.number <= args.ens_size:
            p = ll_to_ecef(row.lat, row.lon)
            for i in tree.query_ball_point(p, r=args.distance):
                assert i < N
                val[i] = val[i] + 1.0

    if not args.no_normalise:
        val = np.minimum(val / args.ens_size, 1.0)

    # write results
    if args.grib_accuracy:
        eccodes.codes_set(h, "bitsPerValue", args.grib_accuracy)
    if args.grib_date:
        eccodes.codes_set(h, "dataDate", args.grib_date)
    if args.grib_step:
        eccodes.codes_set(h, "stepRange", args.grib_step)

    eccodes.codes_set_values(h, val)

    with open(args.fout, "wb") as f:
        eccodes.codes_write(h, f)

    eccodes.codes_release(h)
