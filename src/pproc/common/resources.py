
from dataclasses import dataclass
import functools
import resource
import time
from typing import Callable, Optional, Union


def plural(n: Union[int, float], name: str) -> str:
    return name + ("s" if abs(n) >= 2 else "")


@dataclass
class TimeDecomposition:
    days: int
    hours: int
    minutes: int
    seconds: int
    microseconds: float

    def __init__(
            self,
            days: float = 0.,
            hours: float = 0.,
            minutes: float = 0.,
            seconds: float = 0.,
            microseconds: float = 0.
            ):
        self.days = int(days)
        hours += (days - self.days) * 24
        self.hours = int(hours)
        minutes += (hours - self.hours) * 60
        self.minutes = int(minutes)
        seconds += (minutes - self.minutes) * 60
        self.seconds = int(seconds)
        microseconds += (seconds - self.seconds) * 1e6
        seconds, self.microseconds = divmod(microseconds, 1000000)
        self.seconds += int(seconds)
        minutes, self.seconds = divmod(self.seconds, 60)
        self.minutes += int(minutes)
        hours, self.minutes = divmod(self.minutes, 60)
        self.hours += int(hours)
        days, self.hours = divmod(self.hours, 24)
        self.days += int(days)

    def total_seconds(self) -> float:
        return (
            self.days * 86400
            + self.hours * 3600
            + self.minutes * 60
            + self.seconds
            + self.microseconds * 1e-6
        )

    def pretty(self) -> str:
        raw = f"{self.total_seconds():g} s"
        vals = [
            (num, f"{num:g} {plural(num, name)}")
            for num, name in zip(
                [self.days, self.hours, self.minutes, self.seconds, self.microseconds, 0],
                ['day', 'hour', 'minute', 'second', 'microsecond', '']
            )
        ]
        for (num, main), (snum, sub) in zip(vals[:-1], vals[1:]):
            if num > 0:
                return raw + (f" ({main} {sub})" if snum > 0 else f" ({main})")
        return raw


def pretty_time(seconds: float) -> str:
    """Formats a duration in human-readable units

    The output format is `<raw duration> s (<number> <unit1> [<number2> <unit2>])
    """
    return TimeDecomposition(seconds=seconds).pretty()


def pretty_bytes(bytes: int, decimal: bool = False) -> str:
    """Format a number of bytes in human-readable units

    The output format is `<raw number> B (<human-readable number> <unit>)`

    Parameters
    ----------
    bytes: int
        Value to format
    decimal: bool
        If True, use decimal units (e.g. MB) instead of binary (e.g. MiB)

    Returns
    -------
    str
        Formatted number
    """
    factor = 1000 if decimal else 1024
    unit = "B" if decimal else "iB"
    raw = f"{bytes} {plural(bytes, 'byte')}"
    if bytes < factor:
        return raw
    scaled = bytes
    prefixes = ["k", "M", "G", "T", "P", "E"]
    for i, prefix in enumerate(prefixes):
        scaled /= factor
        if scaled < factor or i == len(prefixes) - 1:
            return raw + f" ({scaled:g} {prefix}{unit})"
    assert False


@dataclass
class ResourceUsage:
    cpu: float
    mem: int

    def __init__(self, cpu: Optional[float] = None, mem: Optional[int] = None):
        res = None
        if cpu is None or mem is None:
            res = resource.getrusage(resource.RUSAGE_SELF)
            if cpu is None:
                cpu = res.ru_utime
            if mem is None:
                mem = res.ru_maxrss * 1024
        self.cpu = cpu
        self.mem = mem

    def __str__(self):
        return (
            f"CPU time: {pretty_time(self.cpu)}, " +
            f"memory: {pretty_bytes(self.mem)}"
        )


@dataclass
class ResourceMeter:
    """Utility to measure resource usage

    Parameters
    ----------
    name: str, optional
        If set, it is added before the report (generated by `__str__` or printed
        by `__exit__`)

    Example
    -------
    ```python
    with ResourceMeter():
        do_something()
    ```
    """
    start: float
    elapsed: float
    start_cpu: float
    elapsed_cpu: float
    mem: int
    name: str = None

    def __init__(self, name: Optional[str] = None):
        self.start = time.perf_counter()
        self.elapsed = 0.
        res = ResourceUsage()
        self.start_cpu = res.cpu
        self.elapsed_cpu = 0.
        self.mem = res.mem
        self.name = name

    def update(self, reset: bool = False):
        t = time.perf_counter()
        res = ResourceUsage()
        if reset:
            self.start = t
            self.start_cpu = res.cpu
        self.elapsed = t - self.start
        self.elapsed_cpu = res.cpu - self.start_cpu
        self.mem = res.mem
        return self

    def __str__(self):
        return (
            ("" if self.name is None else f"{self.name}: ")
            + ", ".join([
                f"wall time: {pretty_time(self.elapsed)}",
                f"CPU time: {pretty_time(self.elapsed_cpu)}",
                f"memory: {pretty_bytes(self.mem)}",
            ])
        )

    def __enter__(self):
        self.update(reset=True)
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.update()
        print(str(self))


def metered(name_or_func=None, out=print, return_meter=False):
    """Automatically measure resource usage of a function

    To be used as a decorator

    Parameters
    ----------
    name_or_func: callable, str or None
        If str, use this instead of the function name when reporting
    out: callable, optional
        If set, call this function with the report as an `str` (default: `print`)
    return_meter: bool
        If True, the function returns a tuple where the first argument is the ResourceMeter
    """
    name = name_or_func if isinstance(name_or_func, str) else None
    def decorator(func: Callable) -> Callable:
        funcname = func.__name__ if name is None else name
        @functools.wraps(func)
        def wrapped(*args, **kwargs):
            meter = ResourceMeter(name=funcname)
            result = func(*args, **kwargs)
            meter.update()
            if out is not None:
                out(str(meter))
            if return_meter:
                return (meter, result)
            return result
        return wrapped
    if isinstance(name_or_func, str) or name_or_func is None:
        return decorator
    return decorator(name_or_func)